-정규표현식
정규표현식은 메타문자를 이용해 원래 그 문자가 가진뜻이 아닌 다른 용도로
문자를 사용해(메타문자) 코드를 작성하는 것을 말한다.
메타문자의 종류는 다음과 같다.
. ^ $ * + ? { } [ ] \ | ( )

이러한 메타문자를 이용해 간단한 정규표현식을 작성하는 법도 배울 것이다.

-문자 클래스 []
문자클래스 []은 []안에 있는 문자들과 매치를 시켜준다.
가령 [ab]가 들어있다면 문자열에 a혹은 b가 있다면 매치가 되는 식이며
'하이픈'(-)을 이용해 범위를 지정할 수도 있다. 
[0-9]라고 지정하면 숫자만 매치가되고 [a-zA-Z]라고 지정할 시 알파벳 문자만
매치된다. 앞에 ^메타문자를 사용시 ! not과 같은 뜻이 된다.
[^0-9]라고 지정시 숫자가 아닌 문자를 매칭한다는 뜻.
이렇게 []문자클래스를 이용해 위처럼 표현하는 것을 정규표현식이라고 한다.
문자클래스에는 위와 같은 정규식을 표현하기 위해 간단하게 축약된 단축어가 있다.
다음과 같다.

\d - 숫자와 매치, [0-9]와 동일한 표현식이다.
\D - 숫자가 아닌 것과 매치, [^0-9]와 동일한 표현식이다.
\s - whitespace 문자와 매치, [ \t\n\r\f\v]와 동일한 표현식이다. 맨 앞의 빈 칸은 공백문자(space)를 의미한다.
\S - whitespace 문자가 아닌 것과 매치, [^ \t\n\r\f\v]와 동일한 표현식이다.
\w - 문자+숫자(alphanumeric)와 매치, [a-zA-Z0-9_]와 동일한 표현식이다.
\W - 문자+숫자(alphanumeric)가 아닌 문자와 매치, [^a-zA-Z0-9_]와 동일한 표현식이다.

-Dot(.)
. 메타문자는 \n을 제외한 모든 문자와 매치된다.
a.b라는 표현식이 있다면 a와 b사이에 어떠한 문자가 있어도 매치가 된다.
acb , agsfgb, a89hjkjb 등등.. 그러나 abc는 매치되지 않는다. a와 b사이에
아무 문자도 없기 때문.
만약 .을 문자 .그대로 인식하게 하고싶다면 문자클래스 []를 사용하여 [.]로 표현하면 된다.

-반복(*)
*메타문자는 *앞에 있는 문자가 0부터 무한대로 반복될 수 있다는 뜻을 가진다.
my*c 라는 표현식이 있을때 myyyc나 myyc나 mc나 모두 매치가 된다.(mc도 y반복이 0번이니까 매치됨)

-반복(+)
메타문자+는 *과 다르게 최소 1번이상 반복되는 문자를 뜻한다. *은 범위가 0~무한대였다면
+는 1~무한대라고 생각하면 된다.
my+c라는 표현식이 있다면 mc는 매치가 안되고 myc myyc등은 매치가 된다.

-반복({m,n},?)
반복횟수 범위를 지정해서 사용하고 싶다면 {}메타 문자를 사용하면 가능하다.
{m,n} 정규식을 사용시 m부터 n까지 반복하는 것을 매치할 수 있고 for문의 range처럼
생략이 가능하다. 슬라이싱처럼 범위를 지정할 수도 있다. {m,}로 지정하면 m부터 무한대
{,n}으로 지정하면 반복횟수가 n이하인 경우다. {0,}는 *과 같고 {1,}는 +와 같다.
{m}으로 컴마(,)없이 사용하면 정확히 m만큼만 반복한 것을 매치한다는 뜻이된다.
*{m}
my{2}c 라는 정규식이 있을때 myyc만 매치되고 나머지는 y가 몇개있던지 매치안됨.
*{m,n}
my{2,5}c라는 정규식이 있을때 myyc는 매치되고 myyyyyyc는 매치안됨.

*?
비슷한 개념의 메타문자?는 {}메타문자를 이용해 표현하자면 {0,1}과 같은 뜻이다.
있어도 되고 없어도 된다는 뜻이다.(2개 이상부터는 매치가 안되지 않을까 생각)
ab?c라는 정규식이 있다면 abc와 ac 둘다 매치가된다. abbc가 되는지는 의문.abs
*,+,?는 위에서 설명했듯 모두 {}메타문자를 이용해 표현이 가능하다.
다만 복잡하게 보일 수 있으니 가능하면 표현할 수 있는 것들은 * + ?로 표현하는 것이 낫다.

-re모듈
위에서 배운 정규표현식을 제공하는 기본 라이브러리에 포함된 모듈이다.
import re
p=re.compile('ab*')
re.compile을 p라는 패턴 객체에 저장시켜준다. 정규식을 컴파일한 것을 패턴이라고 한다.
re모듈의 메소드들을 이용해 컴파일한 패턴이 문자열과 매치하는지 확인해볼 수 있다.

-re모듈의 메소드 종류
match()	= 문자열의 처음부터 정규식과 매치되는지 조사한다.
search() = 문자열 전체를 검색하여 정규식과 매치되는지 조사한다.
findall() =정규식과 매치되는 모든 문자열(substring)을 리스트로 돌려준다.
finditer() = 정규식과 매치되는 모든 문자열(substring)을 반복 가능한 객체로 돌려준다.

-match
import re
p=re.compile('[a-z]+') // 소문자알파벳이 매치되게 한다. +는 1번이상 반복을 뜻함.
m=p.match('python')
print(m)
+없이 '[a-z]'로만 정규식을 만든다면 p만 match되고 종료. []는 []안에 있는 문자와
매치를 시켜주는 것이기 때문에 match 메소드 안의 전체 문자열과 매치되진 않음.
매치가되는 것과 매치 된 출력이 어떻게 나오는 가는 메타문자별로 다 다르니 익숙해져야 할듯.
m=p.match('3 python')의 출력은 None. match메소드는 처음부터 검사하는데 3이 처음에 나오니
바로 종료돼버림.

-search
기존에 작성한 패턴객체p를 둔 상태에서 코드 작성해보자.
m=p.search('python') >>> 'python'이 매치됨
m=p.search('3 python') >>> 'python'이 매치됨
match와 다르게 문자열 전체를 두고 매칭시도를 하기 때문에 문자열에서
정규식에 해당하는 문자열은 다 매치됨. 처음부터 검색할지 말지의 여부에 따라
match or search 사용

-findall
정규식의 조건에 맞게 문자열을 리스트로 돌려줌. 정규식에 해당하지 않는 문자가 나올 시
split의 형태로 리스트에 저장
m=p.findall('life3is3too short')와 같이 작성시 >>> ['life', 'is', 'too', 'short']
즉 p패턴객체에 따라 알파벳에 해당하지 않는 것에 맞게 리스트화 시킨 결과.

-finditer
findall과 비슷하지만 findall은 리스트로서 매치결과를 돌려주었고 finditer은
'반복가능한 객체'로서 결과값을 돌려줌. 쉽게 생각하면 map이나 filter, range같은 함수의
결과값을 단순 print하면 제대로 된 값이 나오지 않지만 for문이나 list사용시 
값을 담을 수 있고 출력도 제대로 할 수 있다는 것.
여기서 배운 점은 반복가능한 자료형(리스트,문자열,튜플,딕셔너리)과 반복가능한 객체는
엄밀히 말하면 다르다는 점.
m=p.finditer('life3is3too short') >>> <callable_iterator object at 0x01F5E390>
다음과 같이 제대로 된 출력이 나오지 않는데 for문을 이용해 출력가능
for result in m: print(result)

-match 객체의 메소드
re모듈은 처음에 compile할때만 re모듈의 메소드 re.compile을 사용했고
compile한 값인 패턴객체를 이용해 match search 등의 메소드를 사용했다.
#일반적으로 모듈의 메소드를 사용하는 방법과 조금 다르다고 느꼈다.
그리고 match search등의 메소드를 이용해 나온 결과값인 match객체를 이용해
또 메소드를 사용할 수 있다. #match 메소드를 이용해 나온 객체만이 match객체만이 아님!
-match 객체 메소드 종류
group() = 매치된 문자열을 돌려준다.
start()	= 매치된 문자열의 시작 위치를 돌려준다.
end() = 매치된 문자열의 끝 위치를 돌려준다.
span() = 매치된 문자열의 (시작, 끝)에 해당하는 튜플을 돌려준다.

m=p.match('python') // 현재 m에는 match객체가 들어있는 상태, 앞전의 실습에서는
이 match 객체를 프린트하면서 확인했으나 이제는 그 객체의 문자열만을 돌려줄 것.
m.group() >>> 'python'
m.start() >>> 0
m.end() >>> 6
m.span() >>> (0,6)
다음과 같이 출력된다. match메소드를 이용했을 경우에는 start번호가 항상0일 수 밖에 없다.
match 메소드 자체가 문자열의 처음부터 검사하기 때문이다.
search 메소드를 사용했다면 얘기가 달라진다
m=p.match('3 python')
m.group() >>> 'python'
m.start() >>> 2
m.end() >>> 8
m.span() >>> (2,8)
#왜 문자열 인덱스처럼 'python'의 끝위치가 5가 아니라 len(string)에 해당하는 6인지는 모르겠다.
p=re.compile('[a-z]+')
m=p.match('python')의 형태로 이루어진 문장은

m=re.match('[a-z]+','python')의 형태와 같다.
그러나 정규식을 쓸때마다 작성해주어야 하기 때문에 한번 만든 패턴객체를 
계속 사용해야할 경우에는 위의 방법이 훨씬 더 편하다.

-컴파일 옵션
DOTALL(S) = .이 줄바꿈 문자를 포함한 모든 문자와 매치 #괄호안은 약어
IGNORECASE(I) = 대소문자 관계없이 매치
MULTILINE(M) = 여러줄과 매치 가능하게 함.
VERBOSE(X) - verbose모드를 사용할 수 있게 함.(정규식을 보기 편하게 만들 수 있고 주석 사용 가능)
컴파일 옵션 사용시 re.DOTALL 혹은 re.S 의 형태로 사용

-DOTALL, S
import re
p=re.compile('a.b') # p=re.compile('a.b',re.S)로 변경시 a\nb출력!
m=p.match('a\nb')
print(m) >>> None

-IGNORECASE, I
p=re.compile('[a-z]+',re.I)
m=p.match('PYTHON')
print(m) >>> 'PYTHON'

-MULTILINE, M
MULTILINE은 ^,$과 관련된 컴파일 옵션이다. ^는 문자열의 처음을 뜻하고
$는 문자열의 끝을 뜻한다.
import re
p = re.compile("^python\s\w+")

data = """python one
life is too short
python two
you need python
python three"""

print(p.findall(data))
다음과 같이 프로그램 실행시 python one만 출력된다. 그 이유는 문자열들의 줄바꿈\n조차
하나의 문자열로 보기 때문에 컴퓨터입장에서는 python one\nlife is too short\n...과 같은
한줄의 문장으로 보일 것이다. 그렇기 때문에 저 문장에 해당하는 정규식의 결과는 
python one만 출력되는 것이 맞다. ^메타문자를 전체문장의 처음이 아닌
각 줄의 처음으로 인식하게 하기 위해서 MULTILINE옵션을 사용하는 것.
아마 전체 문자열에서 \n을 인식하는 메커니즘일 듯.
p = re.compile("^python\s\w+",re.M)으로 변경시 python one, python two, python three 출력
그리고 match나 search 이용시 여러가지으 결과를 받을 수 없음. 둘다 match시키는
기준은 조금 다르지만(문자열 처음부터냐  문자열 전체냐) 매치가 중간에 끊기게 되면
뒤에 해당하는 문자열이 있어도 매치가 되지않고 종료. findall이나 finditer사용시 여러가지
결과 저장 가능.

-VERBOSE  > 생략

-백슬래시 문제 > 생략

